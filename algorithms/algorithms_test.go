package algorithms

import (
	"math"
	"testing"
)

// Allows you to compare 2 floats to a set precision
// Generated by google AI Overview
func compareFloat(f1, f2 float64, precision int) bool {
	tolerance := math.Pow(10, float64(-precision))
	// fmt.Printf("compareFloat(%f, %f, %d): %f < %f\n", f1, f2, precision, math.Abs(f1-f2), tolerance)
	return math.Abs(f1-f2) < tolerance
}

func TestIndel(t *testing.T) {
	// Distance testing
	type distanceTestCase struct {
		inputString      string
		targetString     string
		expectedDistance int
	}

	distanceCases := []distanceTestCase{
		{"", "", 0},
		{"a", "", 1},
		{"", "alumni", 6},
		{"abcd", "abdc", 2},
		{"almni", "alumni", 1},
		{"alyni", "alumni", 3},
		{"inula", "alumni", 9},
		{"alumni", "alumni", 0},
		{"franklin", "alumni", 8},
		{"convesre", "converse", 2},
	}

	for _, currentCase := range distanceCases {
		result := IndelDistance(currentCase.inputString, currentCase.targetString)

		if result != currentCase.expectedDistance {
			t.Errorf("Error in IndelDistance('%s', '%s'), expected %d got %d", currentCase.inputString, currentCase.targetString, currentCase.expectedDistance, result)
		}
	}

}

func TestLevenshtein(t *testing.T) {
	// Distance testing
	type distanceTestCase struct {
		inputString      string
		targetString     string
		expectedDistance int
	}

	// Validated using https://planetcalc.com/1721/
	distanceCases := []distanceTestCase{
		{"", "", 0},
		{"a", "", 1},
		{"", "alumni", 6},
		{"abcd", "abdc", 2},
		{"almni", "alumni", 1},
		{"alyni", "alumni", 2},
		{"inula", "alumni", 5},
		{"alumni", "alumni", 0},
		{"franklin", "alumni", 7},
		{"convesre", "converse", 2},
	}

	for _, currentCase := range distanceCases {
		result := LevenshteinDistance(currentCase.inputString, currentCase.targetString)

		recursiveResult := RecursiveLevenshtein(currentCase.inputString, currentCase.targetString)

		if recursiveResult != currentCase.expectedDistance {
			t.Errorf("Error in LevenshteinDistance('%s', '%s'), (Recursive) %d != %d (Dynamic)", currentCase.inputString, currentCase.targetString, recursiveResult, result)
		}

		if result != currentCase.expectedDistance {
			t.Errorf("Error in LevenshteinDistance('%s', '%s'), expected %d got %d", currentCase.inputString, currentCase.targetString, currentCase.expectedDistance, result)
		}
	}

	// Validated using https://planetcalc.com/1721/
	damerauDistanceCases := []distanceTestCase{
		{"", "", 0},
		{"a", "", 1},
		{"", "alumni", 6},
		{"alumni", "alumni", 0},
		{"almni", "alumni", 1},
		{"alyni", "alumni", 2},
		{"inula", "alumni", 5},
		// Different than original Levenshtein
		{"abcd", "abdc", 1},
		{"franklin", "alumni", 6},
		{"convesre", "converse", 1},
	}

	for _, currentCase := range damerauDistanceCases {
		result := DamerauLevenshtein(currentCase.inputString, currentCase.targetString)

		if result != currentCase.expectedDistance {
			t.Errorf("Error in DamerauLevenshtein('%s', '%s'), expected %d got %d", currentCase.inputString, currentCase.targetString, currentCase.expectedDistance, result)
		}
	}

	// Similarity
	type similarityTestCase struct {
		inputString        string
		targetString       string
		expectedSimilarity float64
	}

	similarityCases := []similarityTestCase{
		{"alumni", "alumni", 1},
		{"almni", "alumni", 0.909},
		{"alyni", "alumni", 0.818},
		{"inula", "alumni", 0.545},
		{"franklin", "alumni", 0.500},
		{"", "", 1},
		{"", "alumni", 0},
		{"a", "", 0},
	}

	for _, currentCase := range similarityCases {
		result := LevenshteinSimilarity(currentCase.inputString, currentCase.targetString)

		if !compareFloat(float64(result), currentCase.expectedSimilarity, 3) {
			t.Errorf("Error in LevenshteinDistance('%s', '%s'), expected %.3f got %.3f", currentCase.inputString, currentCase.targetString, currentCase.expectedSimilarity, result)
		}
	}

}

func TestJaro(t *testing.T) {
	type testCase struct {
		inputString        string
		targetString       string
		expectedSimilarity float64
	}

	// Validated with https://tilores.io/jaro-similarity-algorithm-online-tool
	cases := []testCase{
		{"alumni", "alumni", 1},
		{"almni", "alumni", 0.944},
		{"alyni", "alumni", 0.822},
		{"inula", "alumni", 0.411},
		{"franklin", "alumni", 0.625},
		{"", "", 1},
		{"", "alumni", 0},
		{"a", "", 0},
	}

	for _, currentCase := range cases {
		result := JaroSimilarity(currentCase.inputString, currentCase.targetString)

		if !compareFloat(float64(result), currentCase.expectedSimilarity, 3) {
			t.Errorf("Error in LevenshteinDistance('%s', '%s'), expected %.3f got %.3f", currentCase.inputString, currentCase.targetString, currentCase.expectedSimilarity, result)
		}
	}
}
